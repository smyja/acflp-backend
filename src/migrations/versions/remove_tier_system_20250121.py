"""Remove tier system - drop tier and rate_limit tables and tier_id from user

Revision ID: remove_tier_system_20250121
Revises: 77c60bc1491d
Create Date: 2025-01-21 12:00:00.000000

"""

from collections.abc import Sequence
from typing import Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = "remove_tier_system_20250121"
down_revision: Union[str, None] = "77c60bc1491d"
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Remove tier system components."""
    # ### commands auto generated by Alembic - please adjust! ###
    connection = op.get_bind()
    inspector = sa.inspect(connection)

    # Drop foreign key constraint and tier_id column from user table
    if "user" in inspector.get_table_names():
        # Check if tier_id column exists
        user_columns = [col["name"] for col in inspector.get_columns("user")]
        if "tier_id" in user_columns:
            # Drop foreign key constraint first
            foreign_keys = inspector.get_foreign_keys("user")
            for fk in foreign_keys:
                if "tier_id" in fk["constrained_columns"]:
                    op.drop_constraint(fk["name"], "user", type_="foreignkey")

            # Drop the tier_id column
            op.drop_column("user", "tier_id")

    # Drop rate_limit table if it exists
    if "rate_limit" in inspector.get_table_names():
        op.drop_table("rate_limit")

    # Drop tier table if it exists
    if "tier" in inspector.get_table_names():
        op.drop_table("tier")
    # ### end Alembic commands ###


def downgrade() -> None:
    """Recreate tier system components."""
    # ### commands auto generated by Alembic - please adjust! ###
    # Recreate tier table
    op.create_table(
        "tier",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column("name", sa.VARCHAR(), autoincrement=False, nullable=False),
        sa.Column("created_at", postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
        sa.Column("updated_at", postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
        sa.PrimaryKeyConstraint("id", name="tier_pkey"),
        sa.UniqueConstraint("name", name="tier_name_key"),
    )

    # Recreate rate_limit table
    op.create_table(
        "rate_limit",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column("tier_id", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column("name", sa.VARCHAR(), autoincrement=False, nullable=False),
        sa.Column("path", sa.VARCHAR(), autoincrement=False, nullable=False),
        sa.Column("limit", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column("period", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column("created_at", postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
        sa.Column("updated_at", postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
        sa.ForeignKeyConstraint(["tier_id"], ["tier.id"], name="rate_limit_tier_id_fkey"),
        sa.PrimaryKeyConstraint("id", name="rate_limit_pkey"),
        sa.UniqueConstraint("name", name="rate_limit_name_key"),
    )
    op.create_index("ix_rate_limit_tier_id", "rate_limit", ["tier_id"], unique=False)

    # Add tier_id column back to user table
    connection = op.get_bind()
    inspector = sa.inspect(connection)

    if "user" in inspector.get_table_names():
        user_columns = [col["name"] for col in inspector.get_columns("user")]
        if "tier_id" not in user_columns:
            op.add_column("user", sa.Column("tier_id", sa.INTEGER(), autoincrement=False, nullable=True))
            op.create_index("ix_user_tier_id", "user", ["tier_id"], unique=False)
            op.create_foreign_key("user_tier_id_fkey", "user", "tier", ["tier_id"], ["id"])
    # ### end Alembic commands ###
